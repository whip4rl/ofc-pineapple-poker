<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>OFC Pineapple Poker v2.0</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 10px;
            background: #1a1b26;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #a9b1d6;
        }

        h1 {
            text-align: center;
            margin: 0 0 8px 0;
            font-size: 1.4em;
            color: #7aa2f7;
        }

        h1 small {
            font-size: 0.6em;
            color: #565f89;
        }

        .game-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Top Bar */
        .top-bar {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        button {
            padding: 8px 16px;
            font-size: 13px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #7aa2f7;
            color: #1a1b26;
            font-weight: bold;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #89b4fa;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #414868;
            color: #565f89;
            cursor: not-allowed;
        }

        button.secondary {
            background: #bb9af7;
        }

        button.danger {
            background: #f7768e;
        }

        button.daily {
            background: linear-gradient(135deg, #e0af68 0%, #ff9e64 100%);
        }

        /* Top Grid: AI Board + Hand Area */
        .top-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .quadrant {
            background: #24283b;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        /* Board styling */
        .board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #414868;
        }

        .board-title {
            font-weight: bold;
            font-size: 14px;
        }

        .board-title.player {
            color: #9ece6a;
        }

        .board-title.ai {
            color: #f7768e;
        }

        .board-score {
            font-size: 12px;
        }

        .board-score .royalties {
            color: #e0af68;
        }

        .board-score .foul {
            color: #f7768e;
            font-weight: bold;
        }

        .board-rows {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            justify-content: space-evenly;
        }

        .row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .row-label {
            width: 50px;
            font-size: 11px;
            color: #565f89;
            text-transform: uppercase;
        }

        .row-cards {
            display: flex;
            gap: 4px;
            flex: 1;
        }

        .row-info {
            font-size: 11px;
            color: #7dcfff;
            min-width: 90px;
            text-align: right;
        }

        .row-info.royalty {
            color: #e0af68;
        }

        /* Card Slots */
        .card-slot {
            width: 44px;
            height: 62px;
            border: 2px dashed #414868;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
        }

        .card-slot:hover:not(.filled):not(.disabled) {
            border-color: #7aa2f7;
            background: rgba(122, 162, 247, 0.1);
        }

        .card-slot.highlight {
            border-color: #9ece6a;
            background: rgba(158, 206, 106, 0.15);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .card-slot.filled {
            border: none;
            cursor: default;
        }

        .card-slot.disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Cards */
        .card {
            width: 44px;
            height: 62px;
            background: white;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 3px 4px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            user-select: none;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.3);
            position: relative;
        }

        .card:hover:not(.in-slot):not(.face-down) {
            transform: translateY(-3px);
            box-shadow: 2px 4px 8px rgba(0,0,0,0.4);
        }

        .card.selected {
            outline: 3px solid #9ece6a;
            transform: translateY(-5px);
            box-shadow: 0 6px 16px rgba(158, 206, 106, 0.4);
        }

        .card.in-slot {
            cursor: default;
        }

        .card.face-down {
            background: linear-gradient(135deg, #7aa2f7 0%, #bb9af7 100%);
            cursor: default;
        }

        .card.red {
            color: #f7768e;
        }

        .card.black {
            color: #1a1b26;
        }

        .card .corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
            font-size: 10px;
        }

        .card .corner.bottom {
            align-self: flex-end;
            transform: rotate(180deg);
        }

        .card .center-suit {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
        }

        /* Hand Area (Right Quadrant) */
        .hand-quadrant {
            display: flex;
            flex-direction: column;
        }

        .hand-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid #414868;
        }

        .hand-title {
            font-size: 14px;
            font-weight: bold;
            color: #7dcfff;
        }

        .hand-round {
            font-size: 12px;
            color: #9ece6a;
        }

        .hand-mode {
            font-size: 11px;
            color: #bb9af7;
            margin-bottom: 6px;
        }

        .hand-instruction {
            font-size: 12px;
            color: #565f89;
            text-align: center;
            margin-bottom: 10px;
        }

        .hand-cards {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            flex: 1;
            align-items: center;
        }

        .discard-btn {
            margin-top: 10px;
            width: 100%;
        }

        /* Player Board (Full Width) */
        .player-board {
            background: #24283b;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        }

        /* Bottom 3-Panel Section */
        .bottom-panels {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .panel {
            background: #24283b;
            border-radius: 8px;
            padding: 12px;
        }

        .panel-title {
            font-size: 11px;
            color: #bb9af7;
            text-transform: uppercase;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #414868;
        }

        /* Stats Panel */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .stat-item {
            text-align: center;
            padding: 6px;
            background: #1a1b26;
            border-radius: 5px;
        }

        .stat-label {
            font-size: 9px;
            color: #565f89;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 14px;
            font-weight: bold;
            color: #7dcfff;
        }

        /* Probability Panel */
        .prob-item {
            font-size: 11px;
            padding: 3px 0;
            display: flex;
            justify-content: space-between;
        }

        .prob-label {
            color: #a9b1d6;
        }

        .prob-value {
            color: #9ece6a;
        }

        .prob-value.low {
            color: #f7768e;
        }

        /* Royalty Reference */
        .royalty-table {
            font-size: 10px;
        }

        .royalty-row-title {
            color: #7dcfff;
            margin-top: 6px;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .royalty-row-title:first-child {
            margin-top: 0;
        }

        .royalty-item {
            display: flex;
            justify-content: space-between;
            padding: 1px 0;
            color: #565f89;
        }

        .royalty-item .points {
            color: #e0af68;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: #24283b;
            padding: 25px 35px;
            border-radius: 12px;
            text-align: center;
            max-width: 450px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .modal h2 {
            margin: 0 0 12px 0;
            color: #7aa2f7;
        }

        .modal h2.win {
            color: #9ece6a;
        }

        .modal h2.lose {
            color: #f7768e;
        }

        .modal-score {
            font-size: 2.2em;
            font-weight: bold;
            margin: 12px 0;
        }

        .modal-score.positive {
            color: #9ece6a;
        }

        .modal-score.negative {
            color: #f7768e;
        }

        .modal-breakdown {
            text-align: left;
            background: #1a1b26;
            padding: 12px;
            border-radius: 8px;
            margin: 12px 0;
            font-size: 12px;
        }

        .breakdown-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }

        .breakdown-row.total {
            border-top: 1px solid #414868;
            margin-top: 6px;
            padding-top: 6px;
            font-weight: bold;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        /* Fantasy Land Indicator */
        .fantasy-indicator {
            display: none;
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #bb9af7 0%, #7aa2f7 100%);
            color: #1a1b26;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 13px;
            z-index: 100;
            animation: glow 2s infinite;
        }

        .fantasy-indicator.show {
            display: block;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(187, 154, 247, 0.5); }
            50% { box-shadow: 0 0 25px rgba(187, 154, 247, 0.8); }
        }

        /* Responsive */
        @media (max-width: 700px) {
            .top-grid {
                grid-template-columns: 1fr;
            }

            .bottom-panels {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>OFC Pineapple <small>v2.0</small></h1>

        <div class="top-bar">
            <button id="newGameBtn">New Game</button>
            <button id="dailyBtn" class="daily">Daily Challenge</button>
            <button id="practiceBtn" class="secondary">Practice</button>
        </div>

        <!-- Top Grid: AI Board + Hand Area -->
        <div class="top-grid">
            <!-- Left: AI Board -->
            <div class="quadrant" id="aiBoard">
                <div class="board-header">
                    <span class="board-title ai">AI Opponent</span>
                    <span class="board-score">
                        Royalties: <span class="royalties" id="aiRoyalties">0</span>
                        <span class="foul" id="aiFoul" style="display: none;"> FOUL!</span>
                    </span>
                </div>
                <div class="board-rows" id="aiRows"></div>
            </div>

            <!-- Right: Hand Area -->
            <div class="quadrant hand-quadrant" id="handArea">
                <div class="hand-header">
                    <span class="hand-title" id="handTitle">Your Hand</span>
                    <span class="hand-round">Round <span id="roundNum">1</span>/5</span>
                </div>
                <div class="hand-mode">Mode: <span id="gameMode">VS AI</span><span id="dailyIndicator"></span></div>
                <div class="hand-instruction" id="handInstruction">Click a card, then click a slot to place it</div>
                <div class="hand-cards" id="handCards"></div>
                <button class="discard-btn danger" id="discardBtn" style="display: none;">Discard Remaining Card</button>
            </div>
        </div>

        <!-- Player Board (Full Width) -->
        <div class="player-board" id="playerBoard">
            <div class="board-header">
                <span class="board-title player">Your Board</span>
                <span class="board-score">
                    Royalties: <span class="royalties" id="playerRoyalties">0</span>
                    <span class="foul" id="playerFoul" style="display: none;"> FOUL!</span>
                </span>
            </div>
            <div class="board-rows" id="playerRows"></div>
        </div>

        <!-- Bottom 3-Panel Section -->
        <div class="bottom-panels">
            <!-- Session Stats -->
            <div class="panel">
                <div class="panel-title">Session Stats</div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Games</div>
                        <div class="stat-value" id="statGames">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Net</div>
                        <div class="stat-value" id="statNet">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Best</div>
                        <div class="stat-value" id="statBest">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">FL Runs</div>
                        <div class="stat-value" id="statFantasy">0</div>
                    </div>
                </div>
            </div>

            <!-- Draw Probabilities -->
            <div class="panel">
                <div class="panel-title">Draw Probabilities</div>
                <div id="probContent">
                    <div class="prob-item">
                        <span class="prob-label">No active draws</span>
                    </div>
                </div>
            </div>

            <!-- Royalty Reference -->
            <div class="panel">
                <div class="panel-title">Royalty Reference</div>
                <div class="royalty-table">
                    <div class="royalty-row-title">Front (3 cards)</div>
                    <div class="royalty-item"><span>66-JJ</span><span class="points">1-6</span></div>
                    <div class="royalty-item"><span>QQ/KK/AA</span><span class="points">7/8/9</span></div>
                    <div class="royalty-item"><span>Trips 22-AA</span><span class="points">10-22</span></div>

                    <div class="royalty-row-title">Middle (5 cards)</div>
                    <div class="royalty-item"><span>Trips/Str/Flush</span><span class="points">2/4/8</span></div>
                    <div class="royalty-item"><span>FH/Quads/SF</span><span class="points">12/20/30</span></div>

                    <div class="royalty-row-title">Back (5 cards)</div>
                    <div class="royalty-item"><span>Str/Flush/FH</span><span class="points">2/4/6</span></div>
                    <div class="royalty-item"><span>Quads/SF</span><span class="points">10/15</span></div>
                </div>
            </div>
        </div>
    </div>

    <div class="fantasy-indicator" id="fantasyIndicator">
        FANTASY LAND - Place all 14 cards!
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h2 id="modalTitle">Game Over</h2>
            <div class="modal-score" id="modalScore">+12</div>
            <div class="modal-breakdown" id="modalBreakdown"></div>
            <div class="modal-buttons">
                <button id="modalNewGame">New Game</button>
                <button id="modalDaily" class="daily">Daily Challenge</button>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const SUITS = ['h', 'd', 'c', 's'];
        const SUIT_SYMBOLS = { h: '♥', d: '♦', c: '♣', s: '♠' };
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
        const RANK_VALUES = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };

        // Hand Rankings
        const HAND_RANKS = {
            HIGH_CARD: 0, PAIR: 1, TWO_PAIR: 2, TRIPS: 3, STRAIGHT: 4,
            FLUSH: 5, FULL_HOUSE: 6, QUADS: 7, STRAIGHT_FLUSH: 8, ROYAL_FLUSH: 9
        };

        // Royalty Tables
        const FRONT_PAIR_ROYALTIES = { '6': 1, '7': 2, '8': 3, '9': 4, 'T': 5, 'J': 6, 'Q': 7, 'K': 8, 'A': 9 };
        const FRONT_TRIPS_ROYALTIES = { '2': 10, '3': 11, '4': 12, '5': 13, '6': 14, '7': 15, '8': 16, '9': 17, 'T': 18, 'J': 19, 'Q': 20, 'K': 21, 'A': 22 };
        const MIDDLE_ROYALTIES = { [HAND_RANKS.TRIPS]: 2, [HAND_RANKS.STRAIGHT]: 4, [HAND_RANKS.FLUSH]: 8, [HAND_RANKS.FULL_HOUSE]: 12, [HAND_RANKS.QUADS]: 20, [HAND_RANKS.STRAIGHT_FLUSH]: 30, [HAND_RANKS.ROYAL_FLUSH]: 50 };
        const BACK_ROYALTIES = { [HAND_RANKS.STRAIGHT]: 2, [HAND_RANKS.FLUSH]: 4, [HAND_RANKS.FULL_HOUSE]: 6, [HAND_RANKS.QUADS]: 10, [HAND_RANKS.STRAIGHT_FLUSH]: 15, [HAND_RANKS.ROYAL_FLUSH]: 25 };

        // Seeded random (Mulberry32)
        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        function getTodaySeed() {
            const now = new Date();
            return now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();
        }

        function formatDate(seed) {
            const year = Math.floor(seed / 10000);
            const month = Math.floor((seed % 10000) / 100);
            const day = seed % 100;
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            return `${months[month - 1]} ${day}, ${year}`;
        }

        let rng = Math.random;

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ rank, suit });
                }
            }
            return deck;
        }

        // Game State
        let gameState = {
            phase: 'idle', round: 0, mode: 'vs_ai', deck: [], deadCards: [],
            player: { front: [], middle: [], back: [], hand: [], royalties: 0, isFoul: false },
            ai: { front: [], middle: [], back: [], hand: [], royalties: 0, isFoul: false },
            selectedCard: null, seed: null, inFantasyLand: false, fantasyCards: [],
            placedThisRound: 0, discardedThisRound: false
        };

        // Stats (persisted)
        let stats = { gamesPlayed: 0, gamesWon: 0, bestScore: 0, totalNet: 0, fantasyRuns: 0, dailyResults: {} };

        function loadStats() {
            try {
                const saved = localStorage.getItem('ofcPineappleStats_v2');
                if (saved) stats = JSON.parse(saved);
            } catch (e) { console.error('Failed to load stats:', e); }
        }

        function saveStats() {
            try {
                localStorage.setItem('ofcPineappleStats_v2', JSON.stringify(stats));
            } catch (e) { console.error('Failed to save stats:', e); }
        }

        function cardKey(card) { return card.rank + card.suit; }
        function cardDisplay(card) { return card.rank + SUIT_SYMBOLS[card.suit]; }
        function isRed(card) { return card.suit === 'h' || card.suit === 'd'; }

        // Hand Evaluation
        function evaluateHand(cards) {
            if (!cards || cards.length === 0) return { rank: -1, value: 0, name: 'Empty' };

            const sorted = [...cards].sort((a, b) => RANK_VALUES[b.rank] - RANK_VALUES[a.rank]);
            const values = sorted.map(c => RANK_VALUES[c.rank]);

            const rankCounts = {};
            const suitCounts = {};
            for (const card of cards) {
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
            }

            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const isFlush = cards.length === 5 && Object.values(suitCounts).some(c => c === 5);

            let isStraight = false, straightHigh = 0;
            if (cards.length === 5) {
                const uniqueValues = [...new Set(values)].sort((a, b) => b - a);
                if (uniqueValues.length === 5) {
                    if (uniqueValues[0] - uniqueValues[4] === 4) {
                        isStraight = true;
                        straightHigh = uniqueValues[0];
                    }
                    if (uniqueValues.join(',') === '14,5,4,3,2') {
                        isStraight = true;
                        straightHigh = 5;
                    }
                }
            }

            let handRank, handValue, handName;

            if (isStraight && isFlush) {
                if (straightHigh === 14) { handRank = HAND_RANKS.ROYAL_FLUSH; handName = 'Royal Flush'; }
                else { handRank = HAND_RANKS.STRAIGHT_FLUSH; handName = 'Straight Flush'; }
                handValue = straightHigh;
            } else if (counts[0] === 4) {
                handRank = HAND_RANKS.QUADS; handName = 'Quads';
                const quadRank = Object.keys(rankCounts).find(r => rankCounts[r] === 4);
                handValue = RANK_VALUES[quadRank] * 100;
            } else if (counts[0] === 3 && counts[1] === 2) {
                handRank = HAND_RANKS.FULL_HOUSE; handName = 'Full House';
                const tripRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
                const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                handValue = RANK_VALUES[tripRank] * 100 + RANK_VALUES[pairRank];
            } else if (isFlush) {
                handRank = HAND_RANKS.FLUSH; handName = 'Flush';
                handValue = values.reduce((sum, v, i) => sum + v * Math.pow(15, 4 - i), 0);
            } else if (isStraight) {
                handRank = HAND_RANKS.STRAIGHT; handName = 'Straight';
                handValue = straightHigh;
            } else if (counts[0] === 3) {
                handRank = HAND_RANKS.TRIPS; handName = 'Trips';
                const tripRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
                handValue = RANK_VALUES[tripRank] * 100;
            } else if (counts[0] === 2 && counts[1] === 2) {
                handRank = HAND_RANKS.TWO_PAIR; handName = 'Two Pair';
                const pairs = Object.keys(rankCounts).filter(r => rankCounts[r] === 2).sort((a, b) => RANK_VALUES[b] - RANK_VALUES[a]);
                handValue = RANK_VALUES[pairs[0]] * 100 + RANK_VALUES[pairs[1]];
            } else if (counts[0] === 2) {
                handRank = HAND_RANKS.PAIR; handName = 'Pair';
                const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                handValue = RANK_VALUES[pairRank] * 1000;
                const kickers = sorted.filter(c => c.rank !== pairRank).map(c => RANK_VALUES[c.rank]);
                kickers.forEach((k, i) => handValue += k * Math.pow(15, 2 - i));
            } else {
                handRank = HAND_RANKS.HIGH_CARD; handName = 'High Card';
                handValue = values.reduce((sum, v, i) => sum + v * Math.pow(15, 4 - i), 0);
            }

            // 3-card front row adjustments
            if (cards.length === 3) {
                if (counts[0] === 3) {
                    handRank = HAND_RANKS.TRIPS; handName = 'Trips';
                    const tripRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
                    handValue = RANK_VALUES[tripRank];
                } else if (counts[0] === 2) {
                    handRank = HAND_RANKS.PAIR; handName = 'Pair';
                    const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                    const kicker = sorted.find(c => c.rank !== pairRank);
                    handValue = RANK_VALUES[pairRank] * 100 + RANK_VALUES[kicker.rank];
                } else {
                    handRank = HAND_RANKS.HIGH_CARD; handName = 'High Card';
                    handValue = values.reduce((sum, v, i) => sum + v * Math.pow(15, 2 - i), 0);
                }
            }

            return { rank: handRank, value: handValue, name: handName };
        }

        function compareHands(a, b) {
            const evalA = evaluateHand(a);
            const evalB = evaluateHand(b);
            if (evalA.rank !== evalB.rank) return evalA.rank - evalB.rank;
            return evalA.value - evalB.value;
        }

        function checkFoul(front, middle, back) {
            if (front.length < 3 || middle.length < 5 || back.length < 5) return false;
            return compareHands(back, middle) < 0 || compareHands(middle, front) < 0;
        }

        function calculateRoyalties(front, middle, back) {
            let total = 0;

            if (front.length === 3) {
                const eval3 = evaluateHand(front);
                if (eval3.rank === HAND_RANKS.TRIPS) {
                    const tripRank = Object.keys(front.reduce((acc, c) => { acc[c.rank] = (acc[c.rank] || 0) + 1; return acc; }, {})).find(r => front.filter(c => c.rank === r).length === 3);
                    total += FRONT_TRIPS_ROYALTIES[tripRank] || 0;
                } else if (eval3.rank === HAND_RANKS.PAIR) {
                    const pairRank = Object.keys(front.reduce((acc, c) => { acc[c.rank] = (acc[c.rank] || 0) + 1; return acc; }, {})).find(r => front.filter(c => c.rank === r).length === 2);
                    total += FRONT_PAIR_ROYALTIES[pairRank] || 0;
                }
            }

            if (middle.length === 5) {
                const eval5m = evaluateHand(middle);
                total += MIDDLE_ROYALTIES[eval5m.rank] || 0;
            }

            if (back.length === 5) {
                const eval5b = evaluateHand(back);
                total += BACK_ROYALTIES[eval5b.rank] || 0;
            }

            return total;
        }

        function checkFantasyLandEntry(front, middle, back) {
            if (checkFoul(front, middle, back)) return false;
            if (front.length !== 3) return false;
            const eval3 = evaluateHand(front);
            if (eval3.rank === HAND_RANKS.TRIPS) return true;
            if (eval3.rank === HAND_RANKS.PAIR) {
                const pairRank = Object.keys(front.reduce((acc, c) => { acc[c.rank] = (acc[c.rank] || 0) + 1; return acc; }, {})).find(r => front.filter(c => c.rank === r).length === 2);
                return ['Q', 'K', 'A'].includes(pairRank);
            }
            return false;
        }

        // AI Logic
        function aiPlaceCards(hand, board, isFantasy = false) {
            const placements = [];
            const availableCards = [...hand].sort((a, b) => RANK_VALUES[b.rank] - RANK_VALUES[a.rank]);

            for (const card of availableCards) {
                if (placements.length >= (isFantasy ? 13 : 2)) break;

                const options = [];

                if (board.back.length < 5) {
                    let score = RANK_VALUES[card.rank];
                    const testBack = [...board.back, card];
                    if (hasFlushDraw(testBack)) score += 20;
                    if (hasStraightDraw(testBack)) score += 15;
                    options.push({ row: 'back', score });
                }

                if (board.middle.length + placements.filter(p => p.row === 'middle').length < 5) {
                    options.push({ row: 'middle', score: RANK_VALUES[card.rank] + 5 });
                }

                if (board.front.length + placements.filter(p => p.row === 'front').length < 3) {
                    let score = 0;
                    if (['Q', 'K', 'A'].includes(card.rank)) {
                        const frontCards = [...board.front, ...placements.filter(p => p.row === 'front').map(p => p.card)];
                        if (frontCards.some(c => c.rank === card.rank)) score += 50;
                    }
                    options.push({ row: 'front', score });
                }

                if (options.length > 0) {
                    options.sort((a, b) => b.score - a.score);
                    placements.push({ card, row: options[0].row });
                }
            }

            const discardIdx = isFantasy ? 13 : 2;
            return {
                placements: placements.slice(0, discardIdx),
                discard: availableCards.find(c => !placements.slice(0, discardIdx).some(p => p.card === c))
            };
        }

        function hasFlushDraw(cards) {
            if (cards.length < 3) return false;
            const suitCounts = {};
            for (const card of cards) suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
            return Object.values(suitCounts).some(c => c >= 4);
        }

        function hasStraightDraw(cards) {
            if (cards.length < 4) return false;
            const values = [...new Set(cards.map(c => RANK_VALUES[c.rank]))].sort((a, b) => a - b);
            for (let i = 0; i < values.length - 3; i++) {
                if (values[i + 3] - values[i] <= 4) return true;
            }
            return false;
        }

        // Draw probabilities
        function calculateProbabilities(board, deadCards) {
            const probs = [];
            const remaining = createDeck().filter(c => !deadCards.some(d => cardKey(d) === cardKey(c)));

            if (board.back.length >= 3 && board.back.length < 5) {
                const suitCounts = {};
                for (const card of board.back) suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
                for (const [suit, count] of Object.entries(suitCounts)) {
                    if (count >= 3) {
                        const outs = remaining.filter(c => c.suit === suit).length;
                        const cardsNeeded = 5 - board.back.length;
                        if (outs > 0) {
                            const prob = Math.min(100, Math.round(outs / remaining.length * 100 * (cardsNeeded === 1 ? 1 : 0.5)));
                            probs.push({ label: `Back ${SUIT_SYMBOLS[suit]} flush`, value: prob, outs });
                        }
                    }
                }

                const values = board.back.map(c => RANK_VALUES[c.rank]);
                const gaps = findStraightGaps(values);
                if (gaps.length > 0 && gaps.length <= 2) {
                    const outs = remaining.filter(c => gaps.includes(RANK_VALUES[c.rank])).length;
                    if (outs > 0) {
                        const prob = Math.min(100, Math.round(outs / remaining.length * 100));
                        probs.push({ label: 'Back straight', value: prob, outs });
                    }
                }
            }

            if (board.middle.length >= 3 && board.middle.length < 5) {
                const suitCounts = {};
                for (const card of board.middle) suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
                for (const [suit, count] of Object.entries(suitCounts)) {
                    if (count >= 3) {
                        const outs = remaining.filter(c => c.suit === suit).length;
                        if (outs > 0) {
                            const prob = Math.min(100, Math.round(outs / remaining.length * 100 * 0.5));
                            probs.push({ label: `Mid ${SUIT_SYMBOLS[suit]} flush`, value: prob, outs });
                        }
                    }
                }
            }

            return probs;
        }

        function findStraightGaps(values) {
            values = [...new Set(values)].sort((a, b) => a - b);
            const gaps = [];
            for (let high = 5; high <= 14; high++) {
                const needed = [];
                for (let v = high - 4; v <= high; v++) {
                    const checkVal = v === 1 ? 14 : v;
                    if (!values.includes(checkVal)) needed.push(checkVal);
                }
                if (needed.length === 1 || needed.length === 2) gaps.push(...needed);
            }
            return [...new Set(gaps)];
        }

        // Game Flow
        function initGame(mode = 'vs_ai', seed = null) {
            if (seed !== null) {
                rng = mulberry32(seed);
                gameState.seed = seed;
            } else {
                rng = Math.random;
                gameState.seed = null;
            }

            gameState.deck = shuffle(createDeck());
            gameState.deadCards = [];
            gameState.player = { front: [], middle: [], back: [], hand: [], royalties: 0, isFoul: false };
            gameState.ai = { front: [], middle: [], back: [], hand: [], royalties: 0, isFoul: false };
            gameState.selectedCard = null;
            gameState.round = 1;
            gameState.mode = mode;
            gameState.phase = 'initial';
            gameState.inFantasyLand = false;
            gameState.placedThisRound = 0;
            gameState.discardedThisRound = false;

            gameState.player.hand = gameState.deck.splice(0, 5);
            if (mode !== 'practice') {
                gameState.ai.hand = gameState.deck.splice(0, 5);
                aiPlaceInitial();
            }

            render();
        }

        function aiPlaceInitial() {
            const hand = gameState.ai.hand;
            hand.sort((a, b) => RANK_VALUES[b.rank] - RANK_VALUES[a.rank]);

            const pairs = [], singles = [];
            const rankCounts = {};

            for (const card of hand) rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
            for (const card of hand) {
                if (rankCounts[card.rank] === 2) pairs.push(card);
                else singles.push(card);
            }

            let placed = { front: 0, middle: 0, back: 0 };

            for (let i = 0; i < pairs.length && i < 2; i++) {
                if (['Q', 'K', 'A'].includes(pairs[i].rank) && placed.front < 2) {
                    gameState.ai.front.push(pairs[i]); placed.front++;
                } else if (placed.back < 3) {
                    gameState.ai.back.push(pairs[i]); placed.back++;
                } else {
                    gameState.ai.middle.push(pairs[i]); placed.middle++;
                }
            }

            for (const card of singles) {
                if (placed.back < 2) { gameState.ai.back.push(card); placed.back++; }
                else if (placed.middle < 2) { gameState.ai.middle.push(card); placed.middle++; }
                else if (placed.front < 1) { gameState.ai.front.push(card); placed.front++; }
            }

            gameState.ai.hand = [];
        }

        function dealPineapple() {
            gameState.round++;
            gameState.phase = 'drawing';
            gameState.placedThisRound = 0;
            gameState.discardedThisRound = false;

            gameState.player.hand = gameState.deck.splice(0, 3);

            if (gameState.mode !== 'practice') {
                const aiHand = gameState.deck.splice(0, 3);
                const aiResult = aiPlaceCards(aiHand, gameState.ai);
                for (const placement of aiResult.placements) {
                    gameState.ai[placement.row].push(placement.card);
                }
                if (aiResult.discard) gameState.deadCards.push(aiResult.discard);
            }

            render();
        }

        function placeCard(row) {
            if (!gameState.selectedCard) return;
            if (gameState.phase === 'initial' && gameState.player.hand.length === 0) return;
            if (gameState.phase === 'drawing' && gameState.placedThisRound >= 2) return;

            const maxSize = row === 'front' ? 3 : 5;
            if (gameState.player[row].length >= maxSize) return;

            const cardIdx = gameState.player.hand.findIndex(c => cardKey(c) === cardKey(gameState.selectedCard));
            if (cardIdx === -1) return;

            const card = gameState.player.hand.splice(cardIdx, 1)[0];
            gameState.player[row].push(card);
            gameState.selectedCard = null;
            gameState.placedThisRound++;
            gameState.deadCards.push(card);

            render();
            checkRoundEnd();
        }

        function discardCard() {
            if (gameState.phase !== 'drawing') return;
            if (gameState.placedThisRound < 2) return;
            if (gameState.player.hand.length !== 1) return;

            const discarded = gameState.player.hand.pop();
            gameState.deadCards.push(discarded);
            gameState.discardedThisRound = true;

            render();
            checkRoundEnd();
        }

        function isBoardFull(board) {
            return board.front.length === 3 && board.middle.length === 5 && board.back.length === 5;
        }

        function checkRoundEnd() {
            if (isBoardFull(gameState.player)) { endGame(); return; }

            if (gameState.phase === 'initial') {
                if (gameState.player.hand.length === 0) {
                    if (gameState.round < 5) dealPineapple();
                    else endGame();
                }
            } else if (gameState.phase === 'drawing') {
                if (gameState.placedThisRound >= 2 && gameState.discardedThisRound) {
                    if (gameState.round < 5) dealPineapple();
                    else endGame();
                }
            }
        }

        function endGame() {
            gameState.phase = 'complete';

            gameState.player.isFoul = checkFoul(gameState.player.front, gameState.player.middle, gameState.player.back);
            gameState.player.royalties = gameState.player.isFoul ? 0 : calculateRoyalties(gameState.player.front, gameState.player.middle, gameState.player.back);

            if (gameState.mode !== 'practice') {
                gameState.ai.isFoul = checkFoul(gameState.ai.front, gameState.ai.middle, gameState.ai.back);
                gameState.ai.royalties = gameState.ai.isFoul ? 0 : calculateRoyalties(gameState.ai.front, gameState.ai.middle, gameState.ai.back);
            }

            const score = calculateGameScore();

            stats.gamesPlayed++;
            if (score > 0) stats.gamesWon++;
            stats.totalNet += score;
            if (score > stats.bestScore) stats.bestScore = score;
            if (checkFantasyLandEntry(gameState.player.front, gameState.player.middle, gameState.player.back)) {
                stats.fantasyRuns++;
            }
            saveStats();

            render();
            showResultModal(score);
        }

        function calculateGameScore() {
            if (gameState.mode === 'practice') return gameState.player.royalties;

            if (gameState.player.isFoul && gameState.ai.isFoul) return 0;
            if (gameState.player.isFoul) return -6 - gameState.ai.royalties;
            if (gameState.ai.isFoul) return 6 + gameState.player.royalties;

            let playerWins = 0;
            const frontCmp = compareHands(gameState.player.front, gameState.ai.front);
            const middleCmp = compareHands(gameState.player.middle, gameState.ai.middle);
            const backCmp = compareHands(gameState.player.back, gameState.ai.back);

            if (frontCmp > 0) playerWins++; else if (frontCmp < 0) playerWins--;
            if (middleCmp > 0) playerWins++; else if (middleCmp < 0) playerWins--;
            if (backCmp > 0) playerWins++; else if (backCmp < 0) playerWins--;

            let playerPoints = playerWins;
            if (playerWins === 3) playerPoints += 3;
            else if (playerWins === -3) playerPoints -= 3;

            playerPoints += gameState.player.royalties - gameState.ai.royalties;

            return playerPoints;
        }

        function showResultModal(score) {
            const modal = document.getElementById('modalOverlay');
            const title = document.getElementById('modalTitle');
            const scoreEl = document.getElementById('modalScore');
            const breakdown = document.getElementById('modalBreakdown');

            if (score > 0) { title.textContent = 'You Win!'; title.className = 'win'; }
            else if (score < 0) { title.textContent = 'You Lose'; title.className = 'lose'; }
            else { title.textContent = 'Draw'; title.className = ''; }

            scoreEl.textContent = score >= 0 ? '+' + score : score;
            scoreEl.className = 'modal-score ' + (score >= 0 ? 'positive' : 'negative');

            let html = '';
            if (gameState.mode !== 'practice') {
                const frontCmp = compareHands(gameState.player.front, gameState.ai.front);
                const middleCmp = compareHands(gameState.player.middle, gameState.ai.middle);
                const backCmp = compareHands(gameState.player.back, gameState.ai.back);

                html += `<div class="breakdown-row"><span>Front</span><span>${frontCmp > 0 ? '+1' : frontCmp < 0 ? '-1' : '0'}</span></div>`;
                html += `<div class="breakdown-row"><span>Middle</span><span>${middleCmp > 0 ? '+1' : middleCmp < 0 ? '-1' : '0'}</span></div>`;
                html += `<div class="breakdown-row"><span>Back</span><span>${backCmp > 0 ? '+1' : backCmp < 0 ? '-1' : '0'}</span></div>`;

                const pWins = (frontCmp > 0 ? 1 : 0) + (middleCmp > 0 ? 1 : 0) + (backCmp > 0 ? 1 : 0);
                const aiWins = (frontCmp < 0 ? 1 : 0) + (middleCmp < 0 ? 1 : 0) + (backCmp < 0 ? 1 : 0);
                if (pWins === 3) html += `<div class="breakdown-row"><span>Scoop Bonus</span><span>+3</span></div>`;
                if (aiWins === 3) html += `<div class="breakdown-row"><span>Scooped</span><span>-3</span></div>`;
            }

            html += `<div class="breakdown-row"><span>Your Royalties</span><span>+${gameState.player.royalties}</span></div>`;
            if (gameState.mode !== 'practice') {
                html += `<div class="breakdown-row"><span>AI Royalties</span><span>-${gameState.ai.royalties}</span></div>`;
            }

            if (gameState.player.isFoul) html += `<div class="breakdown-row"><span>FOUL!</span><span>-6</span></div>`;

            if (checkFantasyLandEntry(gameState.player.front, gameState.player.middle, gameState.player.back)) {
                html += `<div class="breakdown-row" style="color: #bb9af7"><span>Fantasy Land Qualified!</span><span>QQ+</span></div>`;
            }

            html += `<div class="breakdown-row total"><span>Total</span><span>${score >= 0 ? '+' : ''}${score}</span></div>`;

            breakdown.innerHTML = html;
            modal.classList.add('show');
        }

        function hideModal() { document.getElementById('modalOverlay').classList.remove('show'); }

        // Rendering
        function render() {
            renderBoard('player', gameState.player);
            if (gameState.mode !== 'practice') {
                renderBoard('ai', gameState.ai, false);
            }
            renderHand();
            renderProbabilities();
            renderStats();
            updateStatus();
        }

        function renderBoard(type, board, hideCards = false) {
            const rows = document.getElementById(type + 'Rows');
            rows.innerHTML = '';

            const rowConfigs = [
                { name: 'front', label: 'Front', max: 3 },
                { name: 'middle', label: 'Middle', max: 5 },
                { name: 'back', label: 'Back', max: 5 }
            ];

            for (const config of rowConfigs) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'row';

                const labelDiv = document.createElement('div');
                labelDiv.className = 'row-label';
                labelDiv.textContent = config.label;
                rowDiv.appendChild(labelDiv);

                const cardsDiv = document.createElement('div');
                cardsDiv.className = 'row-cards';

                for (const card of board[config.name]) {
                    const cardEl = createCardElement(card, hideCards && gameState.phase !== 'complete');
                    cardEl.classList.add('in-slot');
                    cardsDiv.appendChild(wrapInSlot(cardEl));
                }

                const emptySlots = config.max - board[config.name].length;
                for (let i = 0; i < emptySlots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'card-slot';

                    if (type === 'player' && gameState.selectedCard && gameState.phase !== 'complete') {
                        slot.classList.add('highlight');
                        slot.addEventListener('click', () => placeCard(config.name));
                    } else if (type === 'ai') {
                        slot.classList.add('disabled');
                    }

                    cardsDiv.appendChild(slot);
                }

                rowDiv.appendChild(cardsDiv);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'row-info';
                if (board[config.name].length > 0 && (type === 'player' || gameState.phase === 'complete')) {
                    const eval5 = evaluateHand(board[config.name]);
                    infoDiv.textContent = eval5.name;

                    let royalty = 0;
                    if (config.name === 'front' && board.front.length === 3) {
                        royalty = calculateRoyalties(board.front, [], []);
                    } else if (config.name === 'middle' && board.middle.length === 5) {
                        royalty = calculateRoyalties([], board.middle, []);
                    } else if (config.name === 'back' && board.back.length === 5) {
                        royalty = calculateRoyalties([], [], board.back);
                    }
                    if (royalty > 0) {
                        infoDiv.textContent += ` (+${royalty})`;
                        infoDiv.classList.add('royalty');
                    }
                }
                rowDiv.appendChild(infoDiv);

                rows.appendChild(rowDiv);
            }

            const royaltiesEl = document.getElementById(type + 'Royalties');
            const foulEl = document.getElementById(type + 'Foul');

            if (board.front.length === 3 && board.middle.length === 5 && board.back.length === 5) {
                const isFoul = checkFoul(board.front, board.middle, board.back);
                const royalties = isFoul ? 0 : calculateRoyalties(board.front, board.middle, board.back);
                royaltiesEl.textContent = royalties;
                foulEl.style.display = isFoul ? 'inline' : 'none';
            } else {
                royaltiesEl.textContent = '0';
                foulEl.style.display = 'none';
            }
        }

        function renderHand() {
            const handCards = document.getElementById('handCards');
            const handTitle = document.getElementById('handTitle');
            const handInstruction = document.getElementById('handInstruction');
            const discardBtn = document.getElementById('discardBtn');

            handCards.innerHTML = '';

            if (gameState.phase === 'complete') {
                handTitle.textContent = 'Game Complete';
                handInstruction.textContent = '';
                discardBtn.style.display = 'none';
                return;
            }

            if (gameState.phase === 'initial') {
                handTitle.textContent = `Initial Deal (${gameState.player.hand.length})`;
                handInstruction.textContent = 'Place all 5 cards on your board';
            } else if (gameState.phase === 'drawing') {
                const remaining = 2 - gameState.placedThisRound;
                handTitle.textContent = `Pineapple Draw (${gameState.player.hand.length})`;
                if (remaining > 0) {
                    handInstruction.textContent = `Place ${remaining} more card${remaining > 1 ? 's' : ''}, then discard 1`;
                } else {
                    handInstruction.textContent = 'Discard remaining card';
                }
            }

            for (const card of gameState.player.hand) {
                const cardEl = createCardElement(card);
                if (gameState.selectedCard && cardKey(gameState.selectedCard) === cardKey(card)) {
                    cardEl.classList.add('selected');
                }
                cardEl.addEventListener('click', () => selectCard(card));
                handCards.appendChild(cardEl);
            }

            if (gameState.phase === 'drawing' && gameState.placedThisRound >= 2 && gameState.player.hand.length === 1) {
                discardBtn.style.display = 'block';
            } else {
                discardBtn.style.display = 'none';
            }
        }

        function renderProbabilities() {
            const content = document.getElementById('probContent');
            const probs = calculateProbabilities(gameState.player, gameState.deadCards);

            if (probs.length === 0) {
                content.innerHTML = '<div class="prob-item"><span class="prob-label">No active draws</span></div>';
                return;
            }

            content.innerHTML = probs.map(p => `
                <div class="prob-item">
                    <span class="prob-label">${p.label} (${p.outs} outs)</span>
                    <span class="prob-value ${p.value < 20 ? 'low' : ''}">${p.value}%</span>
                </div>
            `).join('');
        }

        function renderStats() {
            document.getElementById('statGames').textContent = stats.gamesPlayed;
            document.getElementById('statNet').textContent = stats.totalNet >= 0 ? '+' + stats.totalNet : stats.totalNet;
            document.getElementById('statBest').textContent = stats.bestScore > 0 ? '+' + stats.bestScore : stats.bestScore;
            document.getElementById('statFantasy').textContent = stats.fantasyRuns;
        }

        function updateStatus() {
            document.getElementById('roundNum').textContent = gameState.round;
            document.getElementById('gameMode').textContent =
                gameState.mode === 'practice' ? 'Practice' :
                gameState.seed ? 'Daily' : 'VS AI';

            const dailyIndicator = document.getElementById('dailyIndicator');
            if (gameState.seed) {
                dailyIndicator.textContent = ' - ' + formatDate(gameState.seed);
            } else {
                dailyIndicator.textContent = '';
            }

            document.getElementById('aiBoard').style.display = gameState.mode === 'practice' ? 'none' : 'flex';
        }

        function selectCard(card) {
            if (gameState.phase === 'complete') return;
            if (gameState.selectedCard && cardKey(gameState.selectedCard) === cardKey(card)) {
                gameState.selectedCard = null;
            } else {
                gameState.selectedCard = card;
            }
            render();
        }

        function createCardElement(card, faceDown = false) {
            const el = document.createElement('div');
            el.className = 'card ' + (isRed(card) ? 'red' : 'black');

            if (faceDown) {
                el.classList.add('face-down');
                el.innerHTML = '';
            } else {
                const display = card.rank === 'T' ? '10' : card.rank;
                el.innerHTML = `
                    <div class="corner top">
                        <span>${display}</span>
                        <span>${SUIT_SYMBOLS[card.suit]}</span>
                    </div>
                    <span class="center-suit">${SUIT_SYMBOLS[card.suit]}</span>
                    <div class="corner bottom">
                        <span>${display}</span>
                        <span>${SUIT_SYMBOLS[card.suit]}</span>
                    </div>
                `;
            }

            return el;
        }

        function wrapInSlot(cardEl) {
            const slot = document.createElement('div');
            slot.className = 'card-slot filled';
            slot.appendChild(cardEl);
            return slot;
        }

        // Event Listeners
        document.getElementById('newGameBtn').addEventListener('click', () => { hideModal(); initGame('vs_ai'); });
        document.getElementById('dailyBtn').addEventListener('click', () => { hideModal(); initGame('vs_ai', getTodaySeed()); });
        document.getElementById('practiceBtn').addEventListener('click', () => { hideModal(); initGame('practice'); });
        document.getElementById('discardBtn').addEventListener('click', discardCard);
        document.getElementById('modalNewGame').addEventListener('click', () => { hideModal(); initGame('vs_ai'); });
        document.getElementById('modalDaily').addEventListener('click', () => { hideModal(); initGame('vs_ai', getTodaySeed()); });

        // Initialize
        loadStats();
        initGame('vs_ai');
    </script>
</body>
</html>
